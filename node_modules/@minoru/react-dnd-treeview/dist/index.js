'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var React = require('react');
var reactDndHtml5Backend = require('react-dnd-html5-backend');
var reactDndMultiBackend = require('react-dnd-multi-backend');
var rdndmbHtml5ToTouch = require('rdndmb-html5-to-touch');
var reactDnd = require('react-dnd');

function _interopDefaultLegacy (e) { return e && typeof e === 'object' && 'default' in e ? e : { 'default': e }; }

var React__default = /*#__PURE__*/_interopDefaultLegacy(React);

/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */

var __assign = function() {
    __assign = Object.assign || function __assign(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};

function __spreadArray(to, from) {
    for (var i = 0, il = from.length, j = to.length; i < il; i++, j++)
        to[j] = from[i];
    return to;
}

var compareItems = function (a, b) {
    if (a.text > b.text) {
        return 1;
    }
    else if (a.text < b.text) {
        return -1;
    }
    return 0;
};

var getTreeItem = function (tree, id) { return tree.find(function (n) { return n.id === id; }); };

var isAncestor = function (tree, sourceId, targetId) {
    if (targetId === 0) {
        return false;
    }
    var targetNode = tree.find(function (node) { return node.id === targetId; });
    if (targetNode === undefined) {
        return false;
    }
    if (targetNode.parent === sourceId) {
        return true;
    }
    return isAncestor(tree, sourceId, targetNode.parent);
};

var isDroppable = function (dragSourceId, dropTargetId, treeContext) {
    var tree = treeContext.tree, rootId = treeContext.rootId, canDrop = treeContext.canDrop;
    if (dragSourceId === undefined) {
        if (dropTargetId === rootId) {
            return true;
        }
        var dropTargetNode = tree.find(function (node) { return node.id === dropTargetId; });
        if (dropTargetNode && dropTargetNode.droppable) {
            return true;
        }
        return false;
    }
    else {
        if (canDrop) {
            var result = canDrop(dragSourceId, dropTargetId);
            if (result !== undefined) {
                return result;
            }
        }
        if (dragSourceId === dropTargetId) {
            return false;
        }
        var dragSourceNode = tree.find(function (node) { return node.id === dragSourceId; });
        if (dragSourceNode === undefined ||
            dragSourceNode.parent === dropTargetId) {
            return false;
        }
        if (dropTargetId === rootId) {
            return true;
        }
        var dropTargetNode = tree.find(function (node) { return node.id === dropTargetId; });
        if (dropTargetNode === undefined || !dropTargetNode.droppable) {
            return false;
        }
        return !isAncestor(tree, dragSourceId, dropTargetId);
    }
};

var mutateTree = function (tree, dragSourceId, dropTargetId) {
    return tree.map(function (node) {
        if (node.id === dragSourceId) {
            return __assign(__assign({}, node), { parent: dropTargetId });
        }
        return node;
    });
};

var getSrcIndex = function (tree, dragSourceId) {
    return tree.findIndex(function (node) { return node.id === dragSourceId; });
};
var getDestIndex = function (tree, dropTargetId, index) {
    if (index === 0) {
        return 0;
    }
    var siblings = tree.filter(function (node) { return node.parent === dropTargetId; });
    if (siblings[index]) {
        return tree.findIndex(function (node) { return node.id === siblings[index].id; });
    }
    return tree.findIndex(function (node) { return node.id === siblings[index - 1].id; }) + 1;
};
var getModifiedIndex = function (tree, dragSourceId, dropTargetId, index) {
    var srcIndex = getSrcIndex(tree, dragSourceId);
    var destIndex = getDestIndex(tree, dropTargetId, index);
    destIndex = destIndex > srcIndex ? destIndex - 1 : destIndex;
    return [srcIndex, destIndex];
};

var arrayMoveMutable = function (array, fromIndex, toIndex) {
    var startIndex = fromIndex < 0 ? array.length + fromIndex : fromIndex;
    if (startIndex >= 0 && startIndex < array.length) {
        var endIndex = toIndex < 0 ? array.length + toIndex : toIndex;
        var item = array.splice(fromIndex, 1)[0];
        array.splice(endIndex, 0, item);
    }
};
var mutateTreeWithIndex = function (tree, dragSourceId, dropTargetId, index) {
    var _a = getModifiedIndex(tree, dragSourceId, dropTargetId, index), srcIndex = _a[0], destIndex = _a[1];
    var newTree = __spreadArray([], tree);
    arrayMoveMutable(newTree, srcIndex, destIndex);
    return newTree.map(function (node) {
        if (node.id === dragSourceId) {
            return __assign(__assign({}, node), { parent: dropTargetId });
        }
        return node;
    });
};

var compareYCoord = function (el, pointerY) {
    var bbox = el.getBoundingClientRect();
    var centerY = bbox.top + bbox.height / 2;
    return pointerY > centerY ? "down" : "up";
};
var getInnerIndex = function (listItems, monitor) {
    var pos = "";
    var index = 0;
    listItems.forEach(function (el, key) {
        var _a;
        var flag = compareYCoord(el, ((_a = monitor.getClientOffset()) === null || _a === void 0 ? void 0 : _a.y) || 0);
        if (pos === "") {
            pos = flag;
        }
        else if (pos !== flag) {
            pos = flag;
            index = key;
        }
        if (key === listItems.length - 1 && flag === "down") {
            index = key + 1;
        }
    });
    return index;
};
var getOuterIndex = function (node, nodeEl, monitor) {
    var parentList = nodeEl.closest('[role="list"]');
    var parentListItems = parentList === null || parentList === void 0 ? void 0 : parentList.querySelectorAll(':scope > [role="listitem"]');
    if (!parentListItems) {
        return null;
    }
    return getInnerIndex(parentListItems, monitor);
};
var getHoverPosition = function (el, pointerY, context) {
    var bbox = el.getBoundingClientRect();
    var offsetY = context.dropTargetOffset;
    var upSideY = bbox.top + offsetY;
    var lowerSideY = bbox.bottom - offsetY;
    if (pointerY > lowerSideY) {
        return "lower";
    }
    else if (pointerY < upSideY) {
        return "upper";
    }
    return "middle";
};
var getDropTarget = function (node, nodeEl, monitor, context) {
    var _a;
    if (!nodeEl) {
        return null;
    }
    if (node === null) {
        var listItems = nodeEl.querySelectorAll(':scope > [role="listitem"]');
        return {
            id: context.rootId,
            index: getInnerIndex(listItems, monitor),
        };
    }
    var dragSource = monitor.getItem();
    var list = nodeEl.querySelector('[role="list"]');
    var hoverPosition = getHoverPosition(nodeEl, ((_a = monitor.getClientOffset()) === null || _a === void 0 ? void 0 : _a.y) || 0, context);
    if (!list) {
        if (hoverPosition === "middle") {
            return {
                id: node.id,
                index: 0,
            };
        }
        if (isDroppable(dragSource.id, node.parent, context)) {
            var outerIndex = getOuterIndex(node, nodeEl, monitor);
            if (outerIndex === null) {
                return null;
            }
            return {
                id: node.parent,
                index: outerIndex,
            };
        }
        return null;
    }
    else {
        if (hoverPosition === "upper") {
            if (isDroppable(dragSource.id, node.parent, context)) {
                var outerIndex = getOuterIndex(node, nodeEl, monitor);
                if (outerIndex === null) {
                    return null;
                }
                return {
                    id: node.parent,
                    index: outerIndex,
                };
            }
            else {
                return {
                    id: node.id,
                    index: 0,
                };
            }
        }
        var listItems = list.querySelectorAll(':scope > [role="listitem"]');
        return {
            id: node.id,
            index: getInnerIndex(listItems, monitor),
        };
    }
};

var getDescendants = function (treeData, id) {
    var descendants = [];
    var search = function (tree, ids) {
        var children = tree.filter(function (node) { return ids.includes(node.parent); });
        if (children.length > 0) {
            descendants = __spreadArray(__spreadArray([], descendants), children);
            search(tree, children.map(function (node) { return node.id; }));
        }
    };
    search(treeData, [id]);
    return descendants;
};

var TreeContext = React__default['default'].createContext({});
var TreeProvider = function (props) {
    var _a = useOpenIdsHelper(props.tree, props.initialOpen), openIds = _a[0], _b = _a[1], handleToggle = _b.handleToggle, handleCloseAll = _b.handleCloseAll, handleOpenAll = _b.handleOpenAll, handleOpen = _b.handleOpen, handleClose = _b.handleClose;
    React.useImperativeHandle(props.treeRef, function () { return ({
        open: function (targetIds) { return handleOpen(targetIds, props.onChangeOpen); },
        close: function (targetIds) { return handleClose(targetIds, props.onChangeOpen); },
        openAll: function () { return handleOpenAll(props.onChangeOpen); },
        closeAll: function () { return handleCloseAll(props.onChangeOpen); },
    }); });
    var canDropCallback = props.canDrop;
    var canDragCallback = props.canDrag;
    var value = __assign(__assign({ listComponent: "ul", listItemComponent: "li", placeholderComponent: "li", sort: true, insertDroppableFirst: true, dropTargetOffset: 0, initialOpen: false }, props), { openIds: openIds, onDrop: function (id, parentId, index) {
            var options = {
                dragSourceId: id,
                dropTargetId: parentId,
                dragSource: getTreeItem(props.tree, id),
                dropTarget: getTreeItem(props.tree, parentId),
            };
            if (props.sort === false) {
                var _a = getModifiedIndex(props.tree, id, parentId, index), destIndex = _a[1];
                options.destinationIndex = destIndex;
                props.onDrop(mutateTreeWithIndex(props.tree, id, parentId, index), options);
                return;
            }
            props.onDrop(mutateTree(props.tree, id, parentId), options);
        }, canDrop: canDropCallback
            ? function (id, parentId) {
                return canDropCallback(props.tree, {
                    dragSourceId: id,
                    dropTargetId: parentId,
                    dragSource: getTreeItem(props.tree, id),
                    dropTarget: getTreeItem(props.tree, parentId),
                });
            }
            : undefined, canDrag: canDragCallback
            ? function (id) { return canDragCallback(getTreeItem(props.tree, id)); }
            : undefined, onToggle: function (id) { return handleToggle(id, props.onChangeOpen); } });
    return (React__default['default'].createElement(TreeContext.Provider, { value: value }, props.children));
};

var DragControlContext = React__default['default'].createContext({});
var initialState$1 = {
    isLock: false,
};
var DragControlProvider = function (props) {
    var _a = React.useState(initialState$1.isLock), isLock = _a[0], setIsLock = _a[1];
    return (React__default['default'].createElement(DragControlContext.Provider, { value: {
            isLock: isLock,
            lock: function () { return setIsLock(true); },
            unlock: function () { return setIsLock(false); },
        } }, props.children));
};

var PlaceholderContext = React__default['default'].createContext({});
var initialState = {
    dropTargetId: undefined,
    index: undefined,
};
var PlaceholderProvider = function (props) {
    var _a = React.useState(initialState.dropTargetId), dropTargetId = _a[0], setDropTargetId = _a[1];
    var _b = React.useState(initialState.index), index = _b[0], setIndex = _b[1];
    var showPlaceholder = function (dropTargetId, index) {
        setDropTargetId(dropTargetId);
        setIndex(index);
    };
    var hidePlaceholder = function () {
        setDropTargetId(initialState.dropTargetId);
        setIndex(initialState.index);
    };
    return (React__default['default'].createElement(PlaceholderContext.Provider, { value: {
            dropTargetId: dropTargetId,
            index: index,
            showPlaceholder: showPlaceholder,
            hidePlaceholder: hidePlaceholder,
        } }, props.children));
};

var Providers = function (props) { return (React__default['default'].createElement(TreeProvider, __assign({}, props),
    React__default['default'].createElement(DragControlProvider, null,
        React__default['default'].createElement(PlaceholderProvider, null,
            React__default['default'].createElement(reactDndMultiBackend.DndProvider, { options: rdndmbHtml5ToTouch.HTML5toTouch }, props.children))))); };

/**
 * This is a hook to allow text selection by mouse in the text input area in a node.
 * Temporarily disables node dragging while the pointer is over the text input area.
 */
var useDragControl = function (ref) {
    var dragControlContext = React.useContext(DragControlContext);
    var lock = function (e) {
        var target = e.target;
        if (target instanceof HTMLInputElement ||
            target instanceof HTMLTextAreaElement) {
            dragControlContext.lock();
        }
    };
    var unlock = function (e) {
        var target = e.target;
        if (target instanceof HTMLInputElement ||
            target instanceof HTMLTextAreaElement) {
            dragControlContext.unlock();
        }
    };
    var handleMouseOver = function (e) { return lock(e); };
    var handleMouseOut = function (e) { return unlock(e); };
    var handleFocusIn = function (e) { return lock(e); };
    var handleFocusOut = function (e) { return unlock(e); };
    React.useEffect(function () {
        var _a, _b, _c, _d;
        if (!ref.current) {
            return;
        }
        // In Firefox or Safari,
        // the focusout event is not fired when the focused element is unmounted.
        // Therefore, it detects the unmounting of a child element
        // and unlocks tree if the focus is on the body element after unmounting.
        var observer = new MutationObserver(function () {
            if (document.activeElement === document.body) {
                dragControlContext.unlock();
            }
        });
        observer.observe(ref.current, {
            subtree: true,
            childList: true,
        });
        (_a = ref.current) === null || _a === void 0 ? void 0 : _a.addEventListener("mouseover", handleMouseOver);
        (_b = ref.current) === null || _b === void 0 ? void 0 : _b.addEventListener("mouseout", handleMouseOut);
        (_c = ref.current) === null || _c === void 0 ? void 0 : _c.addEventListener("focusin", handleFocusIn);
        (_d = ref.current) === null || _d === void 0 ? void 0 : _d.addEventListener("focusout", handleFocusOut);
        return function () {
            var _a, _b, _c, _d;
            observer.disconnect();
            (_a = ref.current) === null || _a === void 0 ? void 0 : _a.removeEventListener("mouseover", handleMouseOver);
            (_b = ref.current) === null || _b === void 0 ? void 0 : _b.removeEventListener("mouseout", handleMouseOut);
            (_c = ref.current) === null || _c === void 0 ? void 0 : _c.removeEventListener("focusin", handleFocusIn);
            (_d = ref.current) === null || _d === void 0 ? void 0 : _d.removeEventListener("focusout", handleFocusOut);
        };
    }, []);
    React.useEffect(function () {
        var _a;
        (_a = ref.current) === null || _a === void 0 ? void 0 : _a.setAttribute("draggable", dragControlContext.isLock ? "false" : "true");
    }, [dragControlContext.isLock]);
};

var ItemTypes = {
    TREE_ITEM: Symbol(),
};

var dragSourceElement = null;
var useDragNode = function (item, ref) {
    var treeContext = useTreeContext();
    var register = function (e) {
        var target = e.target;
        if (target instanceof HTMLElement) {
            var source = target.closest('[role="listitem"]');
            if (e.currentTarget === source) {
                dragSourceElement = source;
            }
        }
    };
    var handleDragStart = function (e) { return register(e); };
    var handleTouchStart = function (e) { return register(e); };
    React.useEffect(function () {
        var _a, _b;
        (_a = ref.current) === null || _a === void 0 ? void 0 : _a.addEventListener("dragstart", handleDragStart);
        (_b = ref.current) === null || _b === void 0 ? void 0 : _b.addEventListener("touchstart", handleTouchStart, {
            passive: true,
        });
        return function () {
            var _a, _b;
            (_a = ref.current) === null || _a === void 0 ? void 0 : _a.removeEventListener("dragstart", handleDragStart);
            (_b = ref.current) === null || _b === void 0 ? void 0 : _b.removeEventListener("touchstart", handleTouchStart);
        };
    }, []);
    var _a = reactDnd.useDrag({
        item: __assign({ type: ItemTypes.TREE_ITEM, ref: ref }, item),
        canDrag: function () {
            var canDrag = treeContext.canDrag;
            if (dragSourceElement !== ref.current) {
                return false;
            }
            if (canDrag) {
                return canDrag(item.id);
            }
            return true;
        },
        collect: function (monitor) { return ({
            isDragging: monitor.isDragging(),
        }); },
    }), isDragging = _a[0].isDragging, drag = _a[1], preview = _a[2];
    return [isDragging, drag, preview];
};

var useDragOver = function (id, isOpen, dragOverHandler) {
    var stack = React.useRef(0);
    var timer = React.useRef(0);
    var onDragEnter = function () {
        stack.current += 1;
        if (stack.current === 1 && !isOpen) {
            timer.current = window.setTimeout(function () { return dragOverHandler(id); }, 500);
        }
    };
    var onDragLeave = function () {
        stack.current -= 1;
        if (stack.current === 0) {
            window.clearTimeout(timer.current);
        }
    };
    var onDrop = function () {
        if (timer.current > 0) {
            window.clearTimeout(timer.current);
        }
        stack.current = 0;
        timer.current = 0;
    };
    return {
        onDragEnter: onDragEnter,
        onDragLeave: onDragLeave,
        onDrop: onDrop,
    };
};

var useDropRoot = function (ref) {
    var treeContext = useTreeContext();
    var placeholderContext = React.useContext(PlaceholderContext);
    var _a = reactDnd.useDrop({
        accept: ItemTypes.TREE_ITEM,
        drop: function (item, monitor) {
            var rootId = treeContext.rootId, onDrop = treeContext.onDrop;
            var dropTargetId = placeholderContext.dropTargetId, index = placeholderContext.index;
            if (monitor.isOver({ shallow: true }) &&
                dropTargetId !== undefined &&
                index !== undefined) {
                onDrop(item.id, rootId, index);
            }
            placeholderContext.hidePlaceholder();
        },
        canDrop: function (item, monitor) {
            var rootId = treeContext.rootId;
            if (monitor.isOver({ shallow: true })) {
                if (item === undefined) {
                    return false;
                }
                return isDroppable(item.id, rootId, treeContext);
            }
            return false;
        },
        hover: function (dragItem, monitor) {
            if (monitor.isOver({ shallow: true })) {
                var rootId = treeContext.rootId;
                var dropTargetId = placeholderContext.dropTargetId, index = placeholderContext.index, showPlaceholder = placeholderContext.showPlaceholder, hidePlaceholder = placeholderContext.hidePlaceholder;
                var dropTarget = getDropTarget(null, ref.current, monitor, treeContext);
                if (dropTarget === null ||
                    !isDroppable(dragItem.id, rootId, treeContext)) {
                    hidePlaceholder();
                    return;
                }
                if (dropTarget.id !== dropTargetId || dropTarget.index !== index) {
                    showPlaceholder(dropTarget.id, dropTarget.index);
                }
            }
        },
        collect: function (monitor) {
            var dragSource = monitor.getItem();
            return {
                isOver: monitor.isOver({ shallow: true }) && monitor.canDrop(),
                dragSource: dragSource,
            };
        },
    }), _b = _a[0], isOver = _b.isOver, dragSource = _b.dragSource, drop = _a[1];
    return [isOver, dragSource, drop];
};

var useDropNode = function (item, ref) {
    var treeContext = useTreeContext();
    var placeholderContext = React.useContext(PlaceholderContext);
    var _a = reactDnd.useDrop({
        accept: ItemTypes.TREE_ITEM,
        drop: function (dragSource, monitor) {
            var dropTargetId = placeholderContext.dropTargetId, index = placeholderContext.index;
            if (monitor.isOver({ shallow: true }) &&
                dropTargetId !== undefined &&
                index !== undefined) {
                treeContext.onDrop(dragSource.id, dropTargetId, index);
            }
            placeholderContext.hidePlaceholder();
        },
        canDrop: function (dragSource, monitor) {
            if (monitor.isOver({ shallow: true })) {
                var dropTarget = getDropTarget(item, ref.current, monitor, treeContext);
                if (dropTarget === null) {
                    return false;
                }
                return isDroppable(dragSource.id, dropTarget.id, treeContext);
            }
            return false;
        },
        hover: function (dragSource, monitor) {
            if (monitor.isOver({ shallow: true })) {
                var dropTargetId = placeholderContext.dropTargetId, index = placeholderContext.index, showPlaceholder = placeholderContext.showPlaceholder, hidePlaceholder = placeholderContext.hidePlaceholder;
                var dropTarget = getDropTarget(item, ref.current, monitor, treeContext);
                if (dropTarget === null ||
                    !isDroppable(dragSource.id, dropTarget.id, treeContext)) {
                    hidePlaceholder();
                    return;
                }
                if (dropTarget.id !== dropTargetId || dropTarget.index !== index) {
                    showPlaceholder(dropTarget.id, dropTarget.index);
                }
            }
        },
        collect: function (monitor) {
            var dragSource = monitor.getItem();
            return {
                isOver: monitor.isOver({ shallow: true }) && monitor.canDrop(),
                dragSource: dragSource,
            };
        },
    }), _b = _a[0], isOver = _b.isOver, dragSource = _b.dragSource, drop = _a[1];
    return [isOver, dragSource, drop];
};

var useOpenIdsHelper = function (tree, initialOpen) {
    var initialOpenIds = [];
    if (initialOpen === true) {
        initialOpenIds = tree
            .filter(function (node) { return node.droppable; })
            .map(function (node) { return node.id; });
    }
    else if (Array.isArray(initialOpen)) {
        initialOpenIds = initialOpen;
    }
    var _a = React.useState(initialOpenIds), openIds = _a[0], setOpenIds = _a[1];
    var handleToggle = function (targetId, callback) {
        var newOpenIds = openIds.includes(targetId)
            ? openIds.filter(function (id) { return id !== targetId; })
            : __spreadArray(__spreadArray([], openIds), [targetId]);
        setOpenIds(newOpenIds);
        if (callback) {
            callback(newOpenIds);
        }
    };
    var handleCloseAll = function (callback) {
        setOpenIds([]);
        if (callback) {
            callback([]);
        }
    };
    var handleOpenAll = function (callback) {
        var newOpenIds = tree
            .filter(function (node) { return node.droppable; })
            .map(function (node) { return node.id; });
        setOpenIds(newOpenIds);
        if (callback) {
            callback(newOpenIds);
        }
    };
    var handleOpen = function (targetIds, callback) {
        var newOpenIds = __spreadArray(__spreadArray([], openIds), tree
            .filter(function (node) {
            return node.droppable &&
                (Array.isArray(targetIds)
                    ? targetIds.includes(node.id)
                    : node.id === targetIds);
        })
            .map(function (node) { return node.id; })).filter(function (value, index, self) { return self.indexOf(value) === index; });
        setOpenIds(newOpenIds);
        if (callback) {
            callback(newOpenIds);
        }
    };
    var handleClose = function (targetIds, callback) {
        var newOpenIds = openIds.filter(function (id) {
            return Array.isArray(targetIds) ? !targetIds.includes(id) : id !== targetIds;
        });
        setOpenIds(newOpenIds);
        if (callback) {
            callback(newOpenIds);
        }
    };
    return [
        openIds,
        { handleToggle: handleToggle, handleCloseAll: handleCloseAll, handleOpenAll: handleOpenAll, handleOpen: handleOpen, handleClose: handleClose },
    ];
};

var useTreeDragLayer = function () {
    return reactDnd.useDragLayer(function (monitor) {
        var itemType = monitor.getItemType();
        return {
            item: monitor.getItem(),
            clientOffset: monitor.getClientOffset(),
            isDragging: monitor.isDragging() && itemType === ItemTypes.TREE_ITEM,
        };
    });
};

var useTreeContext = function () {
    var treeContext = React.useContext(TreeContext);
    if (!treeContext) {
        throw new Error("useTreeContext must be used under TreeProvider");
    }
    return treeContext;
};

var useContainerClassName = function (parentId, isOver) {
    var _a = useTreeContext(), rootId = _a.rootId, rootProps = _a.rootProps, classes = _a.classes;
    var className = (classes === null || classes === void 0 ? void 0 : classes.container) || "";
    if (isOver && (classes === null || classes === void 0 ? void 0 : classes.dropTarget)) {
        className = className + " " + classes.dropTarget;
    }
    if (parentId === rootId && (classes === null || classes === void 0 ? void 0 : classes.root)) {
        className = className + " " + classes.root;
    }
    if (parentId === rootId && (rootProps === null || rootProps === void 0 ? void 0 : rootProps.className)) {
        className = className + " " + rootProps.className;
    }
    className = className.trim();
    return className;
};

var Node = function (props) {
    var treeContext = useTreeContext();
    var placeholderContext = React.useContext(PlaceholderContext);
    var ref = React.useRef(null);
    var item = treeContext.tree.find(function (node) { return node.id === props.id; });
    var openIds = treeContext.openIds, classes = treeContext.classes;
    var open = openIds.includes(props.id);
    if (!item) {
        return null;
    }
    var _a = useDragNode(item, ref), isDragging = _a[0], drag = _a[1], preview = _a[2];
    var _b = useDropNode(item, ref), isOver = _b[0], dragSource = _b[1], drop = _b[2];
    drag(ref);
    if (isDroppable(dragSource === null || dragSource === void 0 ? void 0 : dragSource.id, props.id, treeContext)) {
        drop(ref);
    }
    var hasChild = !!treeContext.tree.find(function (node) { return node.parent === props.id; });
    React.useEffect(function () {
        if (treeContext.dragPreviewRender) {
            preview(reactDndHtml5Backend.getEmptyImage(), { captureDraggingState: true });
        }
    }, []);
    useDragControl(ref);
    var handleToggle = React.useCallback(function () {
        treeContext.onToggle(item.id);
    }, [openIds]);
    var Component = treeContext.listItemComponent;
    var className = (classes === null || classes === void 0 ? void 0 : classes.listItem) || "";
    if (isOver && (classes === null || classes === void 0 ? void 0 : classes.dropTarget)) {
        className = className + " " + classes.dropTarget;
    }
    if (isDragging && (classes === null || classes === void 0 ? void 0 : classes.draggingSource)) {
        className = className + " " + classes.draggingSource;
    }
    var draggable = treeContext.canDrag ? treeContext.canDrag(props.id) : true;
    var isDropTarget = placeholderContext.dropTargetId === props.id;
    var params = {
        depth: props.depth,
        isOpen: open,
        isDragging: isDragging,
        isDropTarget: isDropTarget,
        draggable: draggable,
        hasChild: hasChild,
        containerRef: ref,
        onToggle: handleToggle,
    };
    return (React__default['default'].createElement(Component, { ref: ref, className: className, role: "listitem" },
        treeContext.render(item, params),
        open && hasChild && (React__default['default'].createElement(Container, { parentId: props.id, depth: props.depth + 1 }))));
};

var Placeholder = function (props) {
    var _a = useTreeContext(), placeholderRender = _a.placeholderRender, Component = _a.placeholderComponent, classes = _a.classes;
    var placeholderContext = React.useContext(PlaceholderContext);
    var manager = reactDnd.useDragDropManager();
    var monitor = manager.getMonitor();
    var dragSource = monitor.getItem();
    if (!placeholderRender || !dragSource) {
        return null;
    }
    var visible = props.dropTargetId === placeholderContext.dropTargetId &&
        (props.index === placeholderContext.index ||
            (props.index === undefined &&
                props.listCount === placeholderContext.index));
    if (!visible) {
        return null;
    }
    return (React__default['default'].createElement(Component, { className: (classes === null || classes === void 0 ? void 0 : classes.placeholder) || "" }, placeholderRender(dragSource, { depth: props.depth })));
};

var Container = function (props) {
    var treeContext = useTreeContext();
    var ref = React.useRef(null);
    var nodes = treeContext.tree.filter(function (l) { return l.parent === props.parentId; });
    var view = nodes;
    var sortCallback = typeof treeContext.sort === "function" ? treeContext.sort : compareItems;
    if (treeContext.insertDroppableFirst) {
        var droppableNodes = nodes.filter(function (n) { return n.droppable; });
        var nonDroppableNodes = nodes.filter(function (n) { return !n.droppable; });
        if (treeContext.sort === false) {
            view = __spreadArray(__spreadArray([], droppableNodes), nonDroppableNodes);
        }
        else {
            droppableNodes = droppableNodes.sort(sortCallback);
            nonDroppableNodes = nonDroppableNodes.sort(sortCallback);
            view = __spreadArray(__spreadArray([], droppableNodes), nonDroppableNodes);
        }
    }
    else {
        if (treeContext.sort !== false) {
            view = nodes.sort(sortCallback);
        }
    }
    var _a = useDropRoot(ref), isOver = _a[0], dragSource = _a[1], drop = _a[2];
    if (props.parentId === treeContext.rootId &&
        isDroppable(dragSource === null || dragSource === void 0 ? void 0 : dragSource.id, treeContext.rootId, treeContext)) {
        drop(ref);
    }
    var className = useContainerClassName(props.parentId, isOver);
    var rootProps = treeContext.rootProps || {};
    var Component = treeContext.listComponent;
    return (React__default['default'].createElement(Component, __assign({ ref: ref, role: "list" }, rootProps, { className: className }),
        view.map(function (node, index) { return (React__default['default'].createElement(React__default['default'].Fragment, { key: node.id },
            React__default['default'].createElement(Placeholder, { depth: props.depth, listCount: view.length, dropTargetId: props.parentId, index: index }),
            React__default['default'].createElement(Node, { id: node.id, depth: props.depth }))); }),
        React__default['default'].createElement(Placeholder, { depth: props.depth, listCount: view.length, dropTargetId: props.parentId })));
};

var rootStyle = {
    height: "100%",
    left: 0,
    pointerEvents: "none",
    position: "fixed",
    top: 0,
    width: "100%",
    zIndex: 100,
};
var getItemStyles = function (monitorProps) {
    var offset = monitorProps.clientOffset;
    if (!offset) {
        return {};
    }
    var x = offset.x, y = offset.y;
    var transform = "translate(" + x + "px, " + y + "px)";
    return {
        pointerEvents: "none",
        transform: transform,
    };
};
var DragLayer = function () {
    var context = useTreeContext();
    var monitorProps = useTreeDragLayer();
    if (!monitorProps.isDragging) {
        return null;
    }
    return (React__default['default'].createElement("div", { style: rootStyle },
        React__default['default'].createElement("div", { style: getItemStyles(monitorProps) }, context.dragPreviewRender && context.dragPreviewRender(monitorProps))));
};

function TreeInner(props, ref) {
    return (React__default['default'].createElement(Providers, __assign({}, props, { treeRef: ref }),
        props.dragPreviewRender && React__default['default'].createElement(DragLayer, null),
        React__default['default'].createElement(Container, { parentId: props.rootId, depth: 0 })));
}
var Tree = React.forwardRef(TreeInner);

exports.Container = Container;
exports.DragLayer = DragLayer;
exports.ItemTypes = ItemTypes;
exports.Node = Node;
exports.Tree = Tree;
exports.compareItems = compareItems;
exports.getDescendants = getDescendants;
exports.getDropTarget = getDropTarget;
exports.getModifiedIndex = getModifiedIndex;
exports.getTreeItem = getTreeItem;
exports.isAncestor = isAncestor;
exports.isDroppable = isDroppable;
exports.mutateTree = mutateTree;
exports.mutateTreeWithIndex = mutateTreeWithIndex;
exports.useContainerClassName = useContainerClassName;
exports.useDragControl = useDragControl;
exports.useDragNode = useDragNode;
exports.useDragOver = useDragOver;
exports.useDropNode = useDropNode;
exports.useDropRoot = useDropRoot;
exports.useOpenIdsHelper = useOpenIdsHelper;
exports.useTreeContext = useTreeContext;
exports.useTreeDragLayer = useTreeDragLayer;
//# sourceMappingURL=index.js.map
